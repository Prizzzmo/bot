
# Руководство по разработке

## Введение

Данное руководство предназначено для разработчиков, участвующих в развитии образовательного Telegram-бота по истории России. Документ описывает архитектуру проекта, основные компоненты, соглашения по коду и процесс разработки с акцентом на лучшие практики и оптимизацию производительности.

## Архитектура проекта

Проект реализован на основе модульной архитектуры с четким разделением ответственности между компонентами:

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Telegram API   │◄───►│    Bot Core     │◄───►│   Gemini API    │
└─────────────────┘     └─────────────────┘     └─────────────────┘
                               ▲
                               │
                 ┌─────────────┴─────────────┐
                 │                           │
        ┌────────▼────────┐        ┌────────▼────────┐
        │  CommandHandlers │        │  ContentService │
        └─────────────────┘        └─────────────────┘
```

### Основные компоненты системы:

1. **Bot Core** (`src/bot.py`) - Ядро бота, управляющее взаимодействием с Telegram API
2. **API Client** (`src/api_client.py`) - Клиент для работы с Google Gemini API
3. **Command Handlers** (`src/handlers.py`) - Обработчики команд пользователя
4. **Content Service** (`src/content_service.py`) - Сервис для работы с историческим контентом
5. **Conversation Service** (`src/conversation_service.py`) - Сервис для обработки бесед с пользователем
6. **UI Manager** (`src/ui_manager.py`) - Компонент для управления пользовательским интерфейсом
7. **Analytics Service** (`src/analytics.py`) - Сервис для сбора и анализа статистики
8. **History Map** (`src/history_map.py`) - Сервис для работы с историческими картами
9. **Message Manager** (`src/message_manager.py`) - Компонент для оптимизации обмена сообщениями
10. **Logger** (`src/logger.py`) - Система расширенного логирования

## Соглашения по коду

### Структура файлов

- `src/` - исходный код проекта
- `docs/` - документация
- `tests/` - модульные и интеграционные тесты
- `history_db_generator/` - генератор базы данных исторических событий
- `logs/` - логи работы бота
- `backups/` - резервные копии данных
- `webapp/` - веб-интерфейс для администрирования
- `templates/` - шаблоны для веб-интерфейса
- `generated_maps/` - сгенерированные исторические карты
- `static/` - статические файлы (изображения, стили)

### Стиль кода

1. **Именование:**
   - Классы: `CamelCase` (например, `APIClient`)
   - Функции и методы: `snake_case` (например, `get_historical_info`)
   - Константы: `UPPER_CASE` (например, `MAX_RETRY_COUNT`)
   - Приватные методы и атрибуты: с префиксом `_` (например, `_validate_data`)

2. **Документирование:**
   - Каждый класс и публичный метод должен содержать docstring в формате Google Style
   - Приватные методы должны иметь краткое описание назначения
   - Комментарии должны объяснять "почему", а не "что" делает код
   - Сложные алгоритмы должны сопровождаться подробными комментариями

3. **Обработка ошибок:**
   - Используйте конструкции try-except для обработки исключений
   - Создавайте специфические исключения для различных типов ошибок
   - Логируйте все исключения с контекстом и трассировкой стека
   - Реализуйте механизм повторных попыток для нестабильных операций

4. **Оптимизация:**
   - Используйте кэширование для оптимизации частых запросов
   - Применяйте ленивую инициализацию для тяжелых компонентов
   - Контролируйте использование памяти в долгоживущих процессах
   - Используйте асинхронность для длительных операций ввода-вывода

## База данных исторических событий

### Структура данных

База данных исторических событий хранится в формате JSON и содержит следующие ключевые коллекции:

#### События (`events`)
- `id` - уникальный идентификатор события (UUID)
- `name` - название исторического события
- `description` - подробное описание события
- `short_description` - краткое описание для предварительного просмотра
- `created_at` - время создания записи (Unix timestamp)
- `updated_at` - время последнего обновления записи (Unix timestamp)
- `category_id` - идентификатор категории события
- `year` - год события (числовой формат)
- `start_date` - дата начала события (если применимо)
- `end_date` - дата окончания события (если применимо)
- `location` - географическое местоположение
- `coordinates` - географические координаты (широта, долгота)
- `importance` - уровень исторической значимости (1-10)
- `figures` - массив ключевых исторических личностей, связанных с событием
- `related_events` - массив идентификаторов связанных событий
- `sources` - источники информации
- `tags` - набор тегов для классификации

#### Категории (`categories`)
- `id` - уникальный идентификатор категории
- `name` - название категории
- `description` - описание категории
- `parent_id` - идентификатор родительской категории (для иерархии)

#### Периоды (`periods`)
- `id` - уникальный идентификатор периода
- `name` - название исторического периода
- `description` - описание периода
- `start_year` - год начала периода
- `end_year` - год окончания периода
- `events` - массив идентификаторов событий, относящихся к периоду

### Обновление базы данных

Для обновления базы данных используется скрипт `run_gemini_generator.py`, который:

1. Инициализирует необходимые директории и проверяет конфигурацию
2. Проверяет доступность API ключей Gemini
3. Генерирует структурированный список исторических тем России
4. Для каждой темы:
   - Собирает детальную информацию о событиях
   - Валидирует полученные данные
   - Форматирует и структурирует контент
5. Сохраняет результаты в JSON файл с резервным копированием
6. Создает индексы для оптимизации поиска

```python
# Пример процесса генерации исторического контента
def generate_historical_topic(topic_name, api_client):
    """
    Генерирует структурированный контент по исторической теме.
    
    Args:
        topic_name (str): Название исторической темы
        api_client: Клиент для работы с API
        
    Returns:
        dict: Структурированный контент по теме
    """
    prompt = f"""
    Предоставь структурированную информацию по теме из истории России: "{topic_name}".
    
    Информация должна быть разделена на следующие главы:
    1. Введение и истоки
    2. Основные события и развитие
    3. Ключевые фигуры и реформы
    4. Внешняя политика и влияние
    5. Итоги и историческое значение
    
    Для каждой главы предоставь 2-3 абзаца содержательного текста.
    Используй только исторически достоверные факты.
    """
    
    response = api_client.call_api(prompt, 
                                  temperature=0.2, 
                                  max_tokens=2048,
                                  use_cache=True)
    
    # Обработка и структурирование ответа
    content = parse_and_structure_content(response["text"])
    
    # Добавление метаданных
    content["topic"] = topic_name
    content["generated_at"] = int(time.time())
    content["api_version"] = api_client.get_version()
    
    return content
```

## Процесс разработки

### Настройка окружения разработки

1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/your-organization/history-educational-bot.git
   cd history-educational-bot
   ```

2. Установите зависимости:
   ```bash
   pip install -r requirements.txt
   ```

3. Создайте файл `.env` с необходимыми API ключами (см. `.env.example`):
   ```
   TELEGRAM_TOKEN=your_telegram_token_here
   GEMINI_API_KEY=your_gemini_api_key_here
   ADMIN_ID=your_telegram_id
   ENABLE_WEB_INTERFACE=true
   WEB_INTERFACE_PORT=5000
   ```

4. Инициализируйте начальные данные:
   ```bash
   python run_gemini_generator.py --init-only
   ```

### Запуск бота для разработки

Запуск основного бота:
```bash
python main.py
```

Запуск только веб-интерфейса:
```bash
python run_webapp.py
```

Запуск с режимом отладки:
```bash
python main.py --debug
```

### Тестирование

Запуск всех тестов:
```bash
python -m unittest discover tests
```

Запуск конкретного теста:
```bash
python -m unittest tests/test_api_client.py
```

Запуск с измерением покрытия:
```bash
python -m pytest --cov=src tests/
```

### Обновление документации

1. Документация автоматически генерируется при значительных изменениях кода
2. Для ручной генерации:
   ```bash
   python update_docs.py
   ```
3. При внесении изменений в код обновите соответствующую документацию

## Интеграция с Gemini API

Проект использует Google Gemini API для генерации образовательного контента. API клиент (`src/api_client.py`) предоставляет следующие ключевые методы:

### Основные методы API клиента

- `call_api(prompt, temperature=0.3, max_tokens=1024, use_cache=True)` - базовый метод для вызова Gemini API
- `ask_grok(prompt, use_cache=True)` - упрощенный метод для получения текстового ответа
- `validate_historical_topic(topic)` - проверка, относится ли тема к истории России
- `get_historical_info(topic)` - получение структурированной информации по теме
- `generate_historical_test(topic)` - генерация интерактивного теста по теме

### Оптимизация работы с API

#### 1. Настройка параметров генерации

Для различных типов контента используются оптимальные параметры:

| Тип контента | Temperature | Max Tokens | Описание |
|--------------|-------------|------------|----------|
| Фактологический | 0.1-0.2 | 1024 | Для точной исторической информации |
| Структурированный | 0.2-0.3 | 2048 | Для тем и обзоров |
| Тестовый | 0.5-0.7 | 2048 | Для генерации вопросов и вариантов |
| Творческий | 0.7-0.8 | 1536 | Для объяснений и интерпретаций |

#### 2. Создание эффективных промптов

Практики формирования качественных запросов:

- Включайте контекст и тему в начало промпта
- Указывайте четкую структуру ожидаемого ответа
- Используйте системные инструкции для форматирования
- Применяйте маркеры для разделения секций
- Запрашивайте ответ в JSON формате для структурированных данных

Пример промпта для исторического теста:
```
Создай тест по теме из истории России: "{topic}".

Структура ответа должна быть в следующем формате JSON:
{
    "title": "Название теста",
    "questions": [
        {
            "text": "Текст вопроса 1",
            "options": ["Вариант А", "Вариант Б", "Вариант В", "Вариант Г"],
            "correct_answer": 0,
            "explanation": "Объяснение правильного ответа"
        },
        ...еще 4 вопроса по такой же структуре...
    ]
}

Создай ровно 5 вопросов. Индекс правильного ответа должен быть числом от 0 до 3.
Вопросы должны быть разнообразными по сложности и охватывать разные аспекты темы.
```

#### 3. Реализация интеллектуального кэширования

- Кэширование запросов в памяти с TTL (time-to-live)
- Персистентное хранение кэша в JSON файле
- LRU (Least Recently Used) политика вытеснения
- Валидация и инвалидация кэша при изменении данных

## Система кэширования

Для оптимизации запросов к API используется многоуровневая система кэширования:

### API Cache (`src/api_cache.py`)

- Кэширование запросов к Gemini API с сохранением в JSON
- Уникальные ключи кэша на основе хэша запроса и параметров
- Управление временем жизни кэша (TTL) для разных типов запросов
- Асинхронное сохранение кэша для оптимизации производительности

### Text Cache (`src/text_cache_service.py`)

- Кэширование обработанных текстов и форматированных ответов
- Категоризация кэша по типам контента (темы, тесты, беседы)
- Оптимизация памяти с контролем размера кэша
- Приоритизация популярного контента

### Распределенный кэш (`src/distributed_cache.py`)

- Возможность использования распределенного кэширования (Redis)
- Синхронизация кэша между несколькими экземплярами
- Поддержка атомарных операций обновления
- Гибкие стратегии инвалидации кэша

## Система логирования

Проект использует модульную систему логирования (`src/logger.py`), которая:

- Записывает логи в файл и консоль с ротацией по дням
- Поддерживает различные уровни детализации логирования
- Сохраняет контекст ошибок для эффективной отладки
- Обеспечивает структурированное логирование в JSON формате
- Интегрируется с системой мониторинга для анализа проблем

### Использование логгера

```python
from src.logger import Logger

logger = Logger(log_level=logging.INFO, log_dir="logs")

# Информационные сообщения
logger.info("Инициализация компонента завершена")

# Предупреждения
logger.warning("Некорректные входные данные", 
              {"user_id": 123456, "input": "invalid input"})

# Ошибки с контекстом
try:
    # Код, который может вызвать исключение
    result = some_function()
except Exception as e:
    logger.log_error(e, 
                    {"component": "api_client", 
                     "operation": "fetch_data", 
                     "request_id": "abc123"})
```

## Рекомендации по разработке новых функций

### 1. Добавление новой команды

1. Определите обработчик команды в `handlers.py`:
   ```python
   def new_command_handler(self, update, context):
       """
       Обработчик новой команды.
       
       Args:
           update (telegram.Update): Объект обновления Telegram
           context (telegram.ext.CallbackContext): Контекст разговора
           
       Returns:
           int: Следующее состояние диалога
       """
       try:
           user_id = update.effective_user.id
           self.logger.info(f"Пользователь {user_id} запустил новую команду")
           
           # Логика обработки команды
           message = "Ответ на новую команду"
           
           # Отправка ответа с интерактивной клавиатурой
           keyboard = [
               [InlineKeyboardButton("Вернуться", callback_data="back_to_menu")]
           ]
           update.message.reply_text(
               message,
               reply_markup=InlineKeyboardMarkup(keyboard)
           )
           
           # Возвращаем следующее состояние диалога
           return NEW_COMMAND_STATE
       
       except Exception as e:
           self.logger.log_error(e, {"user_id": user_id, "command": "new_command"})
           update.message.reply_text(
               "Произошла ошибка при обработке команды. Пожалуйста, попробуйте позже."
           )
           return TOPIC
   ```

2. Зарегистрируйте команду в диспетчере в `bot.py`:
   ```python
   # Добавляем обработчик новой команды
   dp.add_handler(CommandHandler('new_command', self.handlers.new_command_handler))
   ```

3. Добавьте новое состояние в `config.py`:
   ```python
   NEW_COMMAND_STATE = 8  # Используйте следующий доступный номер
   ```

4. Обновите обработчик состояний в `ConversationHandler`:
   ```python
   states={
       # Существующие состояния...
       NEW_COMMAND_STATE: [
           MessageHandler(Filters.text & ~Filters.command, 
                         self.handlers.handle_new_command_input),
           CallbackQueryHandler(self.handlers.button_handler, 
                              pattern='^back_to_menu$')
       ],
   }
   ```

### 2. Расширение исторической базы данных

1. Модифицируйте генератор в `history_db_generator/generator.py` для новых типов данных
2. Добавьте новые промпты для генерации специфического контента
3. Обновите схему данных для включения новых полей
4. Запустите обновление базы через `run_gemini_generator.py --update`

### 3. Добавление интеграции с новым API

1. Создайте новый клиент по образцу `api_client.py`:
   ```python
   class NewAPIClient(BaseClient):
       """Клиент для работы с новым API"""
       
       def __init__(self, api_key, logger, cache_service=None):
           """
           Инициализация клиента.
           
           Args:
               api_key (str): API ключ
               logger: Объект логгера
               cache_service: Сервис кэширования (опционально)
           """
           super().__init__(logger)
           self.api_key = api_key
           self.base_url = "https://api.newservice.com/v1"
           self.cache_service = cache_service
       
       def call_api(self, endpoint, params=None, method="GET", use_cache=True):
           """
           Базовый метод для вызова API.
           
           Args:
               endpoint (str): Конечная точка API
               params (dict, optional): Параметры запроса
               method (str): HTTP метод (GET, POST, и т.д.)
               use_cache (bool): Использовать ли кэш
               
           Returns:
               dict: Результат запроса
           """
           # Реализация запроса к API с кэшированием
   ```

2. Зарегистрируйте клиент в `factory.py`:
   ```python
   def create_new_api_client(config, logger, cache_service=None):
       """
       Создание экземпляра нового API клиента.
       
       Args:
           config: Конфигурация приложения
           logger: Объект логгера
           cache_service: Сервис кэширования
           
       Returns:
           NewAPIClient: Экземпляр клиента
       """
       api_key = config.get("NEW_API_KEY")
       return NewAPIClient(api_key, logger, cache_service)
   ```

3. Добавьте клиент в контейнер в `service_container.py`:
   ```python
   def register_services(self):
       """Регистрация сервисов в контейнере"""
       # Существующие сервисы...
       
       # Новый API клиент
       new_api_client = self.factory.create_new_api_client(
           self.config, 
           self.get_service("logger"),
           self.get_service("cache_service")
       )
       self.register_service("new_api_client", new_api_client)
   ```

### 4. Расширение веб-интерфейса

1. Добавьте новый маршрут в `web_server.py`:
   ```python
   @app.route('/new-feature')
   @requires_admin
   def new_feature():
       """Страница новой функциональности"""
       # Получение данных для страницы
       data = service_container.get_service('analytics_service').get_feature_data()
       
       return render_template('new_feature.html', data=data)
   ```

2. Создайте соответствующий HTML-шаблон в директории `templates/`:
   ```html
   {% extends "base.html" %}
   {% block content %}
   <div class="container">
       <h1>Новая функциональность</h1>
       <div class="card">
           <div class="card-body">
               <!-- Содержимое страницы -->
           </div>
       </div>
   </div>
   {% endblock %}
   ```

3. Добавьте JavaScript-функциональность в `webapp/app.js`:
   ```javascript
   // Функциональность для новой фичи
   function initNewFeature() {
       const featureData = document.getElementById('feature-data');
       if (!featureData) return;
       
       // Инициализация компонента
   }
   
   // Вызов при загрузке страницы
   document.addEventListener('DOMContentLoaded', function() {
       // Существующий код...
       initNewFeature();
   });
   ```

## Резервное копирование и восстановление данных

Система автоматически создает резервные копии данных в директории `backups/`. Для ручного создания резервной копии используйте:

```bash
python data_migration.py --backup
```

Для восстановления из резервной копии:

```bash
python data_migration.py --restore <path_to_backup>
```

Для миграции данных между версиями:

```bash
python data_migration.py --migrate --target-version=<version>
```

## Мониторинг и аналитика

Система собирает аналитические данные о работе бота в реальном времени:

1. **Логи** в директории `logs/`:
   - Подробная информация о работе компонентов
   - Ошибки и предупреждения с контекстом
   - Трассировка запросов пользователей

2. **Веб-интерфейс аналитики** (доступен через `run_webapp.py`):
   - Статистика использования бота
   - Популярные темы и запросы
   - Аналитика результатов тестирования
   - Графики активности пользователей

3. **Административные команды** внутри бота (для администраторов):
   - `/admin stats` - Просмотр базовой статистики
   - `/admin logs` - Просмотр последних логов
   - `/admin users` - Информация об активных пользователях

## Обработка API-ключей

Для безопасной работы с API-ключами:

1. **Хранение ключей**:
   - Используйте переменные окружения (`.env` файл)
   - Никогда не сохраняйте ключи в исходном коде
   - Используйте шифрование для хранения в конфигурационных файлах

2. **Доступ к ключам**:
   - Централизованный доступ через объект конфигурации
   - Кэширование в памяти для оптимизации производительности
   - Логирование доступа к ключам для аудита

3. **Ротация ключей**:
   - Периодическое обновление ключей для повышения безопасности
   - Поддержка нескольких ключей для бесперебойной работы
   - Мониторинг использования ключей для отслеживания аномалий

Пример безопасного доступа к API-ключам:

```python
def get_api_key(key_name):
    """
    Получение API ключа с защитой от утечки.
    
    Args:
        key_name (str): Название ключа
        
    Returns:
        str: API ключ
    """
    # Приоритет: переменные окружения -> конфигурационный файл -> значение по умолчанию
    key = os.environ.get(key_name)
    
    if not key and os.path.exists('.env'):
        # Загрузка из .env файла
        from dotenv import load_dotenv
        load_dotenv()
        key = os.environ.get(key_name)
    
    if not key and os.path.exists('config.json'):
        # Загрузка из конфигурационного файла
        try:
            with open('config.json', 'r') as f:
                config = json.load(f)
                key = config.get(key_name)
        except:
            pass
    
    if not key:
        raise KeyError(f"API ключ {key_name} не найден")
    
    # Маскирование ключа для логирования
    masked_key = key[:4] + '*' * (len(key) - 8) + key[-4:]
    logging.debug(f"Загружен API ключ {key_name}: {masked_key}")
    
    return key
```

## Дополнительные инструменты

### 1. Анализ базы данных событий

```bash
python analyze_events_db.py --output=report.html
```

Этот инструмент выполняет:
- Проверку целостности данных
- Анализ распределения событий по периодам
- Выявление связей между событиями
- Создание интерактивного отчета с визуализациями

### 2. Очистка кэша

```bash
python clear_cache.py --all
python clear_cache.py --older-than=30d
```

Инструмент для управления системой кэширования:
- Очистка устаревших записей кэша
- Проверка целостности кэша
- Оптимизация размера кэш-файлов

### 3. Создание презентационных документов

```bash
python create_presentation_doc.py --format=docx,md
```

Генератор презентационных материалов:
- Создание документов в различных форматах
- Генерация визуализаций и диаграмм
- Включение статистики использования
- Адаптация для различных аудиторий

---

Если у вас возникли вопросы по разработке, обратитесь к руководителю проекта или создайте issue в репозитории проекта.
