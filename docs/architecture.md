
# Архитектура системы

## Обзор

Данная система представляет собой образовательного Telegram-бота для изучения истории России. Система спроектирована с использованием объектно-ориентированного подхода и следующих паттернов проектирования:

- **Factory** - для создания и инициализации компонентов системы
- **Service Locator** - для централизованного управления сервисами
- **Singleton** - для объектов, которые должны существовать в единственном экземпляре
- **Facade** - для упрощения взаимодействия с подсистемами
- **Strategy** - для реализации различных алгоритмов обработки данных
- **Observer** - для обеспечения оповещения компонентов о событиях

## Диаграмма компонентов

Система состоит из следующих основных компонентов:

1. **Telegram Bot** - основной компонент, отвечающий за взаимодействие с пользователем через Telegram API
2. **API Client** - компонент для взаимодействия с внешними API (Gemini API)
3. **Content Service** - сервис для управления контентом (исторические темы, тесты)
4. **Analytics Service** - сервис для сбора и анализа статистики использования бота
5. **Admin Panel** - компонент для управления ботом администраторами
6. **Web Server** - компонент для предоставления веб-интерфейса администраторам
7. **UI Manager** - компонент для создания и управления элементами интерфейса бота
8. **History Map** - компонент для работы с историческими картами
9. **Caching Services** - компоненты для кэширования данных и оптимизации работы

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Telegram API   │◄───►│    Bot Core     │◄───►│   Gemini API    │
└─────────────────┘     └─────────────────┘     └─────────────────┘
                               ▲
                               │
                 ┌─────────────┴─────────────┐
                 │                           │
        ┌────────▼────────┐        ┌────────▼────────┐
        │  CommandHandlers │        │  ContentService │
        └─────────────────┘        └─────────────────┘
                 ▲                           ▲
                 │                           │
      ┌──────────┴──────────┐     ┌─────────┴─────────┐
      │                     │     │                   │
┌─────▼─────┐         ┌────▼────┐ │ ┌───────────┐    │
│UIManager  │         │APIClient │ │ │APICache   │    │
└───────────┘         └─────────┘ │ └───────────┘    │
      ▲                    ▲      │       ▲          │
      │                    │      │       │          │
      └────────┬───────────┘      └────┬──┘          │
               │                       │             │
        ┌──────▼──────┐         ┌─────▼─────┐┌────────▼────────┐
        │MessageManager│         │TextCache  ││AnalyticsService│
        └─────────────┘         └───────────┘└─────────────────┘
               ▲                                     ▲
               │                                     │
        ┌──────▼──────┐                     ┌────────▼────────┐
        │Logger       │                     │HistoryMapService│
        └─────────────┘                     └─────────────────┘
```

## Слои архитектуры

Архитектура системы разделена на следующие слои:

1. **Presentation Layer** - компоненты, отвечающие за взаимодействие с пользователем
   - Telegram Bot (Bot класс)
   - Command Handlers
   - UI Manager

2. **Business Logic Layer** - компоненты, реализующие бизнес-логику приложения
   - Content Service
   - Test Service
   - Topic Service
   - Conversation Service
   - History Map Service
   - Analytics Service

3. **Data Access Layer** - компоненты для доступа к данным
   - API Client
   - API Cache
   - Text Cache Service
   - Storage Service

4. **Infrastructure Layer** - компоненты, обеспечивающие работу системы
   - Logger
   - Service Container
   - State Manager
   - Web Server
   - Performance Monitor

## Взаимодействие компонентов

1. Пользователь отправляет сообщение боту через Telegram
2. Bot принимает сообщение и передает его в Command Handlers
3. Command Handlers обрабатывает сообщение и использует необходимые сервисы для формирования ответа
4. Сервисы взаимодействуют с API Client для получения данных
5. API Client использует кэш для оптимизации запросов
6. Content Service формирует контент для ответа пользователю
7. UI Manager формирует пользовательский интерфейс
8. Bot отправляет ответ пользователю

## Компоненты системы в деталях

### 1. Bot (src/bot.py)

Основной компонент системы, отвечающий за инициализацию и настройку бота Telegram, регистрацию обработчиков команд и управление жизненным циклом приложения.

**Основные методы**:
- `__init__` - инициализация бота и конфигурации
- `setup` - настройка бота и подключение обработчиков
- `start` - запуск бота в режиме поллинга или веб-хука
- `stop` - остановка бота и освобождение ресурсов

### 2. CommandHandlers (src/handlers.py)

Компонент, отвечающий за обработку команд и сообщений пользователя. Реализует бизнес-логику взаимодействия с пользователем.

**Основные методы**:
- `start` - обработка команды /start
- `button_handler` - обработка нажатий на кнопки
- `choose_topic` - обработка выбора темы
- `handle_custom_topic` - обработка пользовательской темы
- `handle_test` - обработка тестирования
- `handle_conversation` - обработка режима беседы
- `error_handler` - обработка ошибок

### 3. ContentService (src/content_service.py)

Сервис, отвечающий за генерацию и управление контентом (темы, тесты, беседы).

**Основные методы**:
- `get_topics` - получение списка тем
- `get_topic_info` - получение информации по теме
- `generate_test` - генерация теста по теме
- `check_answer` - проверка ответа на вопрос
- `get_related_topics` - получение связанных тем

### 4. APIClient (src/api_client.py)

Компонент для взаимодействия с внешними API (в первую очередь с Google Gemini API).

**Основные методы**:
- `call_api` - вызов API с указанными параметрами
- `get_historical_info` - получение исторической информации
- `generate_historical_test` - генерация исторического теста
- `ask_grok` - запрос к модели в режиме беседы

### 5. UIManager (src/ui_manager.py)

Компонент для создания и управления элементами пользовательского интерфейса.

**Основные методы**:
- `create_main_menu` - создание главного меню
- `create_topics_menu` - создание меню выбора тем
- `format_topic_info` - форматирование информации о теме
- `format_test_question` - форматирование вопроса теста

### 6. HistoryMapService (src/history_map.py)

Новый компонент для работы с историческими картами и визуализациями.

**Основные методы**:
- `generate_battle_map` - генерация карты сражения
- `create_timeline` - создание временной линии
- `generate_territory_map` - генерация карты территорий
- `can_visualize_topic` - проверка возможности визуализации темы

### 7. AnalyticsService (src/analytics.py)

Компонент для сбора и анализа статистики использования бота.

**Основные методы**:
- `track_view_topic` - отслеживание просмотра темы
- `track_test_result` - отслеживание результата теста
- `track_user_question` - отслеживание вопроса пользователя
- `get_user_analytics` - получение аналитики пользователя
- `generate_recommendations` - генерация рекомендаций

### 8. WebServer (src/web_server.py)

Компонент для реализации веб-интерфейса административной панели.

**Основные методы**:
- `run` - запуск веб-сервера
- `setup_routes` - настройка маршрутов
- `authenticate` - аутентификация пользователя
- `serve_panel` - отображение административной панели

### 9. Logger (src/logger.py)

Компонент для логирования событий в системе.

**Основные методы**:
- `info` - логирование информационного сообщения
- `warning` - логирование предупреждения
- `error` - логирование ошибки
- `log_error` - логирование ошибки с контекстом
- `get_logs` - получение логов с фильтрацией

## Управление зависимостями

Зависимости между компонентами управляются с помощью:

1. **Dependency Injection** - зависимости передаются в конструкторы объектов
2. **Service Container** - централизованное хранилище и управление сервисами
3. **Factory** - создание объектов с заранее настроенными зависимостями

Пример создания компонентов через Factory:

```python
def create_bot(config):
    """Создание экземпляра бота с необходимыми зависимостями"""
    # Создаем базовые компоненты
    logger = create_logger(config)
    api_client = create_api_client(config, logger)
    
    # Создаем сервисы
    content_service = create_content_service(api_client, logger)
    test_service = create_test_service(api_client, logger)
    analytics_service = create_analytics_service(logger)
    history_map_service = create_history_map_service(api_client, logger)
    
    # Создаем менеджеры
    ui_manager = create_ui_manager()
    message_manager = create_message_manager()
    
    # Создаем обработчики команд
    handlers = create_command_handlers(content_service, test_service, 
                                      analytics_service, history_map_service, 
                                      ui_manager, message_manager, logger)
    
    # Создаем и настраиваем веб-сервер
    web_server = create_web_server(analytics_service, logger) if config.enable_web_server else None
    
    # Создаем бота
    bot = Bot(config, handlers, logger, web_server)
    
    return bot
```

## Особенности реализации

1. **Логирование** - все компоненты используют единый интерфейс логирования, обеспечивающий:
   - Запись логов с различным уровнем важности
   - Ротацию логов по дням
   - Форматирование сообщений с дополнительным контекстом
   - Отслеживание ошибок с сохранением стека вызовов

2. **Обработка ошибок** - централизованная обработка ошибок для обеспечения стабильности работы:
   - Перехват исключений в обработчиках команд
   - Информативные сообщения для пользователя в случае ошибок
   - Детальное логирование для последующего анализа
   - Система повторных попыток для нестабильных операций

3. **Кэширование** - многоуровневое кэширование для оптимизации производительности:
   - API Cache - кэширование результатов обращений к внешним API
   - Text Cache - кэширование часто используемых текстов и форматированных сообщений
   - Memory Cache - кэширование объектов в памяти для быстрого доступа
   - LRU Cache - политика вытеснения для оптимального использования памяти

4. **Асинхронность** - обработка запросов в отдельных потоках для обеспечения отзывчивости бота:
   - Многопоточная обработка запросов пользователей
   - Асинхронное сохранение данных
   - Параллельное выполнение тяжелых операций
   - Планирование фоновых задач

5. **Расширяемость** - использование интерфейсов и абстрактных классов для возможности расширения системы:
   - Интерфейсы для ключевых компонентов
   - Стратегии для различных алгоритмов
   - Фабрики для создания различных реализаций
   - Отдельные модули для независимого развития

## Оптимизации производительности

1. **Интеллектуальное кэширование**:
   - Сохранение результатов частых запросов к API
   - LRU-политика вытеснения для оптимального использования памяти
   - Асинхронное сохранение кэша в файловое хранилище

2. **Эффективная работа с API Gemini**:
   - Дифференцированные настройки запросов для разных типов контента
   - Двухуровневая проверка релевантности запросов
   - Повторные попытки с экспоненциальной задержкой при сбоях

3. **Оптимизация работы в Telegram**:
   - Управление историей сообщений для улучшения пользовательского опыта
   - Эффективное использование инлайн-клавиатур
   - Асинхронная обработка веб-хуков для снижения нагрузки

4. **Системные оптимизации**:
   - Многопоточная обработка для параллельного выполнения задач
   - Ротация логов по дням для эффективного хранения 
   - Периодическая очистка устаревших данных

## Безопасность

1. **Защита данных**:
   - Минимальный сбор пользовательских данных
   - Отсутствие хранения личной информации
   - Очистка истории диалогов по истечении определенного времени

2. **Безопасность API**:
   - Хранение ключей API в переменных окружения
   - Валидация запросов перед отправкой
   - Лимитирование частоты запросов

3. **Защита от злоупотреблений**:
   - Проверка релевантности запросов на историческую тематику
   - Фильтрация некорректных запросов
   - Мониторинг аномальной активности

## Заключение

Архитектура системы спроектирована с учетом современных подходов к разработке программного обеспечения и ориентирована на обеспечение:
- Высокой модульности и расширяемости
- Четкого разделения ответственности между компонентами
- Оптимальной производительности
- Надежности и стабильности работы
- Безопасности данных и защиты от злоупотреблений

Эта архитектура позволяет эффективно развивать проект, добавлять новую функциональность и поддерживать существующий код с минимальными затратами.
